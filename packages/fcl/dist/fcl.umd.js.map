{"version":3,"file":"fcl.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/actor/index.js","../src/actor/mailbox/index.js","../src/config/index.js","../src/default-config.js","../src/send/index.js","../src/decode/index.js","../src/transaction/index.js","../src/current-user/render-authz-frame.js","../src/current-user/composite-id-from-provider.js","../src/current-user/fetch-hook.js","../src/current-user/index.js","../src/current-user/poll-for-authz-updates.js","../src/current-user/render-authn-frame.js","../src/fcl.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {mailbox as createMailbox} from \"./mailbox\"\nimport queueMicrotask from \"queue-microtask\"\n\nexport const INIT = \"INIT\"\nexport const SUBSCRIBE = \"SUBSCRIBE\"\nexport const UNSUBSCRIBE = \"UNSUBSCRIBE\"\nexport const EXIT = \"EXIT\"\nexport const TERMINATE = \"TERMINATE\"\n\nconst root =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  (typeof window === \"object\" && window.window === window && window)\n\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY\nvar pid = 0b0\n\nconst DEFAULT_TIMEOUT = 5000\nconst DEFAULT_TAG = \"---\"\nexport const send = (addr, tag, data, opts = {}) =>\n  new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT\n\n    if (expectReply && timeout) {\n      setTimeout(\n        () =>\n          reject(new Error(`Timeout: ${timeout}ms passed without a response.`)),\n        timeout\n      )\n    }\n\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject,\n    }\n\n    try {\n      root.FCL_REGISTRY[addr].mailbox.deliver(payload)\n      if (!expectReply) reply(true)\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, error)\n    }\n  })\n\nexport const kill = addr => {\n  delete root.FCL_REGISTRY[addr]\n}\n\nconst fromHandlers = (handlers = {}) => async ctx => {\n  if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx)\n  __loop: while (1) {\n    const letter = await ctx.receive()\n    try {\n      if (letter.tag === EXIT) {\n        if (typeof handlers[TERMINATE] === \"function\") {\n          await handlers[TERMINATE](ctx, letter, letter.data || {})\n        }\n        break __loop\n      }\n      await handlers[letter.tag](ctx, letter, letter.data || {})\n    } catch (error) {\n      console.error(`${ctx.self()} Error`, letter, error)\n    } finally {\n      continue __loop\n    }\n  }\n}\n\nexport const spawn = (fn, addr = null) => {\n  if (addr == null) addr = ++pid\n  if (root.FCL_REGISTRY[addr] != null) return addr\n\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: createMailbox(),\n    subs: new Set(),\n    kvs: {},\n  }\n\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: (to, tag, data, opts = {}) => {\n      opts.from = addr\n      return send(to, tag, data, opts)\n    },\n    broadcast: (tag, data, opts = {}) => {\n      opts.from = addr\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts)\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key]\n      return value == null ? fallback : value\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key]\n    },\n    update: (key, fn) => {\n      if (key != null)\n        root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key])\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs)\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key)\n          ? {...acc, [key]: root.FCL_REGISTRY[addr].kvs[key]}\n          : acc\n      }, {})\n    },\n    merge: (data = {}) => {\n      Object.keys(data).forEach(\n        key => (root.FCL_REGISTRY[addr].kvs[key] = data[key])\n      )\n    },\n  }\n\n  if (typeof fn === \"object\") fn = fromHandlers(fn)\n\n  queueMicrotask(async () => {\n    await fn(ctx)\n    kill(addr)\n  })\n\n  return addr\n}\n","export const mailbox = () => {\n  const queue = []\n  var next\n\n  return {\n    async deliver(msg) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift())\n        next = undefined\n      }\n    },\n\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","import {spawn, send, SUBSCRIBE, UNSUBSCRIBE} from \"../actor\"\n\nconst NAME = \"config\"\nconst PUT = \"PUT_CONFIG\"\nconst GET = \"GET_CONFIG\"\nconst UPDATE = \"UPDATE_CONFIG\"\nconst DELETE = \"DELETE_CONFIG\"\nconst WHERE = \"WHERE_CONFIG\"\nconst UPDATED = \"CONFIG/UPDATED\"\n\nconst identity = v => v\n\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, {key, value}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\")\n    ctx.put(key, value)\n    ctx.broadcast(UPDATED, ctx.all())\n  },\n  [GET]: (ctx, letter, {key, fallback}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/get\")\n    letter.reply(ctx.get(key, fallback))\n  },\n  [UPDATE]: (ctx, letter, {key, fn}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/update\")\n    ctx.update(key, fn || identity)\n    ctx.broadcast(UPDATED, ctx.all())\n  },\n  [DELETE]: (ctx, letter, {key}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\")\n    ctx.delete(key)\n    ctx.broadcast(UPDATED, ctx.all())\n  },\n  [WHERE]: (ctx, letter, {pattern}) => {\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\")\n    letter.reply(ctx.where(pattern))\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, ctx.all())\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n}\n\nspawn(HANDLERS, NAME)\n\nfunction put(key, value) {\n  send(NAME, PUT, {key, value})\n  return config()\n}\n\nfunction get(key, fallback) {\n  return send(NAME, GET, {key, fallback}, {expectReply: true, timeout: 10})\n}\n\nfunction update(key, fn = identity) {\n  send(NAME, UPDATE, {key, fn})\n  return config()\n}\n\nfunction _delete(key) {\n  send(NAME, DELETE, {key})\n  return config()\n}\n\nfunction where(pattern) {\n  return send(NAME, WHERE, {pattern}, {expectReply: true, timeout: 10})\n}\n\nfunction subscribe(callback) {\n  const EXIT = \"@EXIT\"\n  const self = spawn(async ctx => {\n    ctx.send(NAME, SUBSCRIBE)\n    while (1) {\n      const letter = await ctx.receive()\n      if (letter.tag === EXIT) {\n        ctx.send(NAME, UNSUBSCRIBE)\n        return\n      }\n      callback(letter.data)\n    }\n  })\n  return () => send(self, EXIT)\n}\n\nexport function config() {\n  return {put, get, update, delete: _delete, where, subscribe}\n}\n","import {config} from \"./config\"\n\nconfig()\n  .put(\"accessNode.api\", \"http://localhost:8080\")\n  .put(\"challenge.handshake\", \"http://localhost:8700/authenticate\")\n","import {\n  resolve,\n  resolveParams,\n  resolveAccounts,\n  resolveSignatures,\n  build,\n  send as sdkSend,\n} from \"@onflow/sdk\"\nimport {config} from \"../config\"\n\nexport const send = async (args = [], opts = {}) => {\n  opts.node = opts.node || (await config().get(\"accessNode.api\"))\n\n  if (Array.isArray(args)) args = build(args)\n\n  const ix = await resolve(args, [\n    resolveParams,\n    resolveAccounts,\n    resolveSignatures,\n  ])\n\n  return sdkSend(ix, opts)\n}\n","import {decodeResponse} from \"@onflow/sdk\"\nimport {config} from \"../config\"\n\nexport const decode = async response => {\n  const decodersFromConfig = await config().where(/^decoder\\./)\n  const decoders = Object.fromEntries(\n    Object.entries(decodersFromConfig).map(([pattern, xform]) => {\n      pattern = `/${pattern.replace(/^decoder\\./, \"\")}$/`\n      return [pattern, xform]\n    })\n  )\n  return decodeResponse(response, decoders)\n}\n","import \"../default-config\"\nimport {config} from \"../config\"\nimport {spawn, send, INIT, SUBSCRIBE, UNSUBSCRIBE} from \"../actor\"\nimport {send as fclSend} from \"../send\"\nimport {decode} from \"../decode\"\nimport {getTransactionStatus} from \"@onflow/sdk\"\n\nconst POLL_RATE = 1000\n\nconst UPDATED = \"TRANSACTION/UPDATED\"\nconst SNAPSHOT = \"SNAPSHOT\"\nconst POLL = \"POLL\"\n\nconst fetchTxStatus = async transactionId => {\n  const response = await fclSend([getTransactionStatus(transactionId)])\n  return decode(response)\n}\n\nconst isSealed = tx => tx.status === 4\n\nconst HANDLERS = {\n  [INIT]: async ctx => {\n    const tx = await fetchTxStatus(ctx.self())\n    if (!isSealed(tx)) setTimeout(() => send(ctx.self(), POLL), POLL_RATE)\n    ctx.merge(tx)\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, ctx.all())\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n  [SNAPSHOT]: async (ctx, letter) => {\n    letter.replay(ctx.all())\n  },\n  [POLL]: async ctx => {\n    const tx = await fetchTxStatus(ctx.self())\n    if (!isSealed(tx)) setTimeout(() => send(ctx.self(), POLL), POLL_RATE)\n    ctx.merge(tx)\n    ctx.broadcast(UPDATED, ctx.all())\n  },\n}\n\nconst spawnTransaction = transactionId => {\n  if (typeof transactionId === \"object\")\n    transactionId = transactionId.transactionId\n  if (transactionId == null) throw new Error(\"transactionId required\")\n  return spawn(HANDLERS, transactionId)\n}\n\nexport function transaction(transactionId) {\n  function snapshot() {\n    const txId = spawnTransaction(transactionId)\n    return send(txId, SNAPSHOT, null, {expectReply: true, timeout: 10})\n  }\n\n  function subscribe(callback) {\n    const txId = spawnTransaction(transactionId)\n    const EXIT = \"@EXIT\"\n    const self = spawn(async ctx => {\n      ctx.send(txId, SUBSCRIBE)\n      while (1) {\n        const letter = await ctx.receive()\n        if (letter.tag === EXIT) {\n          ctx.send(txId, UNSUBSCRIBE)\n          return\n        }\n        callback(letter.data)\n      }\n    })\n    return () => send(self, EXIT)\n  }\n\n  function onceSealed() {\n    return new Promise(resolve => {\n      const unsub = subscribe(transaction => {\n        if (isSealed(transaction)) {\n          resolve(transaction)\n          unsub()\n        }\n      })\n    })\n  }\n\n  return {\n    snapshot,\n    subscribe,\n    onceSealed,\n  }\n}\n\ntransaction.isSealed = isSealed\n","const FRAME_ID = 'FCL_IFRAME_AUTHZ'\n\nexport function renderAuthzFrame(hook) {\n    console.log('renderAuthzFrame')\n    if (document.getElementById(FRAME_ID)) return\n    var url = new URL(hook.endpoint)\n    for (let [key, value] of Object.entries(hook.params || {})) {\n        url.searchParams.append(key, value)\n    }\n\n    const $frame = document.createElement('iframe')\n    $frame.src = url.href\n    $frame.id = FRAME_ID\n    $frame.style.height = hook.height || '500px'\n    $frame.style.maxHeight = '90vh'\n    $frame.style.width = hook.width || '400px'\n    $frame.style.maxWidth = '90vw'\n    $frame.style.display = 'block'\n    $frame.style.background = hook.background || '#fff'\n    $frame.style.position = 'fixed'\n    $frame.style.top = '5vh'\n    $frame.style.right = 'calc(50vw)'\n    $frame.style.transform = 'translateX(50%)'\n    $frame.style.boxShadow = '0 4px 8px -4px black'\n    $frame.frameBorder = '0'\n    document.body.append($frame)\n\n    return () => {\n        if (document.getElementById(FRAME_ID)) {\n            document.getElementById(FRAME_ID).remove()\n        }\n    }\n}\n","export const compositeIdFromProvider = (provider = {}) => {\n  const addr = provider.addr\n  const pid = provider.pid\n  if (addr == null || pid == null) return null\n  return `${addr}/${pid}`\n}\n","const METHODS = {\n  \"HTTP/POST\": \"POST\",\n  \"HTTP/GET\": \"GET\",\n}\n\nexport const fetchHook = async (hook, body) => {\n  const url = new URL(hook.endpoint)\n  for (let [key, value] of Object.entries(hook.params || {})) {\n    url.searchParams.append(key, value)\n  }\n\n  body = body ? JSON.stringify(body) : undefined\n\n  return fetch(url, {\n    method: METHODS[hook.method],\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body,\n  }).then(d => d.json())\n}\n","import '../default-config'\nimport { config } from '../config'\nimport { spawn, send, INIT, SUBSCRIBE, UNSUBSCRIBE } from '../actor'\nimport { send as fclSend } from '../send'\nimport { getAccount } from '@onflow/sdk'\nimport { renderAuthnFrame } from './render-authn-frame'\nimport { renderAuthzFrame } from './render-authz-frame'\nimport { compositeIdFromProvider } from './composite-id-from-provider'\nimport { fetchHook } from './fetch-hook'\nimport { pollForAuthzUpdates } from './poll-for-authz-updates'\nimport { Identity } from '@onflow/types'\n\nconst NAME = 'CURRENT_USER'\nconst UPDATED = 'CURRENT_USER/UPDATED'\nconst SNAPSHOT = 'SNAPSHOT'\nconst SET_CURRENT_USER = 'SET_CURRENT_USER'\nconst DEL_CURRENT_USER = 'DEL_CURRENT_USER'\nconst GET_AS_PARAM = 'GET_AS_PARAM'\n\nconst CHALLENGE_RESPONSE_EVENT = 'FCL::CHALLENGE::RESPONSE'\n\nconst DATA = `{\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"verified\":null,\n  \"identity\":{\n    \"name\":null,\n    \"addr\":null,\n    \"avatar\":null,\n    \"cover\":null,\n    \"color\":null,\n    \"bio\":null\n  },\n  \"scoped\":{},\n  \"provider\":{\n    \"addr\":null,\n    \"pid\":null,\n    \"name\":null,\n    \"icon\":null\n  },\n  \"authorizations\":[]\n}`\n\nconst HANDLERS = {\n    [INIT]: (ctx) => {\n        ctx.merge(JSON.parse(DATA))\n    },\n    [SUBSCRIBE]: (ctx, letter) => {\n        ctx.subscribe(letter.from)\n        ctx.send(letter.from, UPDATED, ctx.all())\n    },\n    [UNSUBSCRIBE]: (ctx, letter) => {\n        ctx.unsubscribe(letter.from)\n    },\n    [SNAPSHOT]: async (ctx, letter) => {\n        letter.reply(ctx.all())\n    },\n    [SET_CURRENT_USER]: async (ctx, letter, data) => {\n        ctx.merge(data)\n        ctx.broadcast(UPDATED, ctx.all())\n    },\n    [DEL_CURRENT_USER]: async (ctx, letter) => {\n        ctx.merge(JSON.parse(DATA))\n        ctx.broadcast(UPDATED, ctx.all())\n    },\n    [GET_AS_PARAM]: async (ctx, letter, { key }) => {\n        letter.reply({ key, value: ctx.get('addr', null), xform: Identity })\n    }\n}\n\nconst identity = (v) => v\nconst spawnCurrentUser = () => spawn(HANDLERS, NAME)\n\nasync function authenticate() {\n    console.log('Test')\n    return new Promise(async (resolve) => {\n        spawnCurrentUser()\n\n        const user = await snapshot()\n        if (user.loggedIn) return resolve(user)\n\n        const unrender = renderAuthnFrame({\n            handshake: await config().get('challenge.handshake'),\n            scope: await config().get('challenge.scope'),\n            nonce: 'asdf',\n            l6n: window.location.origin\n        })\n\n        // Instead of re-implementing the event listener in RN, let's just\n        // simulate the data that might be passed from the iframe\n\n        const simulatedData = {\n            type: 'FCL::CHALLENGE::RESPONSE',\n            addr: '0000000000000000000000000000000000000004',\n            paddr: 'asdf8701',\n            code: '4d7e3f65-7d1c-49dd-97d8-537ba6aa462b',\n            exp: '1591742214881',\n            hks: 'http://192.168.1.132:8701/flow/hooks',\n            nonce: 'asdf',\n            l6n: null\n        }\n\n        const simulateMessage = async ({ data, origin }) => {\n            if (data.type !== CHALLENGE_RESPONSE_EVENT) return\n            unrender()\n            const url = new URL(data.hks)\n            url.searchParams.append('code', data.code)\n\n            console.log('using url:', url)\n\n            const user = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            }).then((d) => d.json())\n\n            console.log('user:', user)\n\n            send(NAME, SET_CURRENT_USER, {\n                ...user,\n                cid: compositeIdFromProvider(user.provider),\n                loggedIn: true,\n                verified: true\n            })\n\n            const snapshot1 = await snapshot()\n            console.log('Snapshot:', snapshot1)\n            resolve(snapshot1)\n        }\n\n        console.log('Waiting 1 second...')\n        setTimeout(() => {\n            console.log('Simulating message...')\n            simulateMessage({ data: simulatedData })\n        }, 1000)\n    })\n}\n\n//     window.addEventListener('message', async ({ data, origin }) => {\n//         if (data.type !== CHALLENGE_RESPONSE_EVENT) return\n//         unrender()\n//         const url = new URL(data.hks)\n//         url.searchParams.append('code', data.code)\n\n//         const user = await fetch(url, {\n//             method: 'GET',\n//             headers: {\n//                 'Content-Type': 'application/json'\n//             }\n//         }).then((d) => d.json())\n\n//         send(NAME, SET_CURRENT_USER, {\n//             ...user,\n//             cid: compositeIdFromProvider(user.provider),\n//             loggedIn: true,\n//             verified: true\n//         })\n//         resolve(await snapshot())\n//     })\n// })\n// }\n\nfunction unauthenticate() {\n    spawnCurrentUser()\n    send(NAME, DEL_CURRENT_USER)\n}\n\nasync function authorization(account) {\n    spawnCurrentUser()\n    await authenticate()\n\n    const user = await snapshot()\n    let sequenceNum\n    if (account.role.proposer) {\n        const acct = await info()\n        // TODO: There will be an update to the getAccount that will\n        //       make the key consitent ie: { keyId, sequenceNum, publicKey }\n        //       instead of the current equivalent { index, sequenceNumber }\n        const key = acct.keys.find((key) => key.index === user.keyId)\n        sequenceNum = key.sequenceNumber\n    }\n\n    const signingFunction = async (message) => {\n        const user = await snapshot()\n        const acct = await info()\n        const resp = await fetchHook(user.authorizations[0], message)\n\n        let unrender = () => {}\n        if (resp.local && resp.local.length > 0) {\n            console.log('RENDER LOCAL')\n            unrender = renderAuthzFrame(resp.local[0])\n        }\n\n        const result = await pollForAuthzUpdates(resp.authorizationUpdates)\n        unrender()\n        return result\n    }\n\n    return {\n        ...account,\n        addr: user.addr,\n        keyId: user.keyId,\n        sequenceNum,\n        signature: account.signature || null,\n        signingFunction,\n        resolve: null,\n        roles: account.roles\n    }\n}\n\nfunction param(key) {\n    return async function innerParam() {\n        spawnCurrentUser()\n        await authenticate()\n        return send(NAME, GET_AS_PARAM, { key }, { expectReply: true, timeout: 10 })\n    }\n}\n\nfunction subscribe(callback) {\n    spawnCurrentUser()\n    const EXIT = '@EXIT'\n    const self = spawn(async (ctx) => {\n        ctx.send(NAME, SUBSCRIBE)\n        while (1) {\n            const letter = await ctx.receive()\n            if (letter.tag === EXIT) {\n                ctx.send(NAME, UNSUBSCRIBE)\n                return\n            }\n            callback(letter.data)\n        }\n    })\n    return () => send(self, EXIT)\n}\n\nfunction snapshot() {\n    spawnCurrentUser()\n    return send(NAME, SNAPSHOT, null, { expectReply: true, timeout: 0 })\n}\n\nasync function info() {\n    spawnCurrentUser()\n    const { addr } = await snapshot()\n    if (addr == null) throw new Error('No Flow Address for Current User')\n    const { account } = await fclSend([getAccount(addr)])\n    return account\n}\n\nexport const currentUser = () => {\n    return {\n        authenticate,\n        unauthenticate,\n        authorization,\n        param,\n        subscribe,\n        snapshot\n    }\n}\n","import {fetchHook} from \"./fetch-hook\"\n\nexport const pollForAuthzUpdates = hook =>\n  new Promise(async (resolve, reject) => {\n    const resp = await fetchHook(hook)\n\n    if (resp.status === \"APPROVED\") {\n      resolve(resp.compositeSignature)\n    } else if (resp.status === \"DECLINED\") {\n      reject({status: resp.status, reason: resp.reason})\n    } else {\n      setTimeout(() => {\n        resolve(pollForAuthzUpdates(resp.authorizationUpdates))\n      }, 500)\n    }\n  })\n","const FRAME_ID = 'FCL_IFRAME_CHALLENGE'\n\nexport function renderAuthnFrame({ handshake, scope, nonce, l6n }) {\n    console.log('in renderAuthnFrame with:', { handshake, scope, nonce, l6n })\n    // if (document.getElementById(FRAME_ID)) return\n    var url = new URL(handshake)\n    url.searchParams.append('l6n', l6n)\n    url.searchParams.append('nonce', nonce)\n    if (scope) url.searchParams.append('scope', scope.split(' ').join('+'))\n    console.log('url:', url)\n\n    // const $frame = document.createElement('iframe')\n    // $frame.src = url.href\n    // $frame.id = FRAME_ID\n    // $frame.style.height = '500px'\n    // $frame.style.maxHeight = '90vh'\n    // $frame.style.width = '400px'\n    // $frame.style.maxWidth = '90vw'\n    // $frame.style.display = 'block'\n    // $frame.style.background = '#fff'\n    // $frame.style.position = 'fixed'\n    // $frame.style.top = '5vh'\n    // $frame.style.right = 'calc(50vw)'\n    // $frame.style.transform = 'translateX(50%)'\n    // $frame.style.boxShadow = '0 4px 8px -4px black'\n    // $frame.frameBorder = '0'\n    // document.body.append($frame)\n\n    return () => {\n        console.log('Unrender placeholder...')\n        // if (document.getElementById(FRAME_ID)) {\n        //     document.getElementById(FRAME_ID).remove()\n        // }\n    }\n}\n","import \"./default-config\"\nexport {config} from \"./config\"\nexport {send} from \"./send\"\nexport {decode} from \"./decode\"\nexport {transaction as tx} from \"./transaction\"\n\nimport {currentUser} from \"./current-user\"\nexport {currentUser}\n\nexport const authenticate = () => currentUser().authenticate()\nexport const unauthenticate = () => currentUser().unauthenticate()\n\n// proxy sdk\nexport {isOk, isBad, why, cadence, cdc} from \"@onflow/sdk\"\nexport {\n  transaction,\n  script,\n  ping,\n  getAccount,\n  getEvents,\n  getLatestBlock,\n  getTransactionStatus,\n} from \"@onflow/sdk\"\nexport {\n  authorizations,\n  authorization,\n  params,\n  param,\n  proposer,\n  payer,\n  limit,\n  ref,\n} from \"@onflow/sdk\"\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_for","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","Symbol","iterator","asyncIterator","root","self","global","window","FCL_REGISTRY","pid","send","addr","tag","data","opts","Promise","reply","expectReply","timeout","setTimeout","Error","payload","to","from","mailbox","deliver","error","console","spawn","fn","next","queue","msg","push","shift","undefined","receive","resolve","subs","Set","kvs","handlers","ctx","broadcast","subscribe","sub","add","unsubscribe","put","key","get","fallback","delete","keys","Object","all","where","pattern","reduce","acc","merge","forEach","letter","finalizer","recover","queueMicrotask","kill","NAME","PUT","GET","UPDATED","identity","HANDLERS","_letter","config","_delete","_exit2","args","node","Array","isArray","build","resolveParams","resolveAccounts","resolveSignatures","ix","sdkSend","decode","response","decodersFromConfig","decoders","fromEntries","entries","map","xform","replace","decodeResponse","fetchTxStatus","transactionId","fclSend","getTransactionStatus","isSealed","tx","status","replay","spawnTransaction","transaction","txId","snapshot","onceSealed","unsub","FRAME_ID","compositeIdFromProvider","provider","METHODS","HTTP/POST","HTTP/GET","fetchHook","hook","url","URL","endpoint","params","searchParams","append","JSON","stringify","fetch","method","headers","Content-Type","d","json","info","spawnCurrentUser","getAccount","account","authorization","authenticate","user","keyId","sequenceNum","signature","signingFunction","message","acct","authorizations","resp","unrender","local","length","log","document","getElementById","$frame","createElement","src","href","id","style","height","maxHeight","width","maxWidth","display","background","position","top","right","transform","boxShadow","frameBorder","remove","renderAuthzFrame","pollForAuthzUpdates","compositeSignature","reason","authorizationUpdates","roles","role","proposer","find","index","sequenceNumber","loggedIn","handshake","scope","nonce","l6n","split","join","renderAuthnFrame","location","origin","simulatedData","type","paddr","code","exp","hks","CHALLENGE_RESPONSE_EVENT","SET_CURRENT_USER","cid","verified","snapshot1","simulateMessage","DATA","parse","Identity","unauthenticate","param","currentUser"],"mappings":"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"}